import pyclamd
import hashlib
import os
import time

class MalwareDetection:
    def __init__(self, log_file="network_log.txt"):
        """Initialize with a log file path."""
        self.log_file = log_file.rstrip('/') # Ensure log_file is treated as a file name
        
        # Set base directory directly to /app
        self.base_dir = "/app" # This is for the log file path and any file-based operations
        self.clam = None # Initialize clam attribute
        
        # Ensure log file path is not a directory
        log_path = os.path.join(self.base_dir, self.log_file)
        if os.path.isdir(log_path):
            import shutil
            shutil.rmtree(log_path)
            print(f"Removed directory {log_path} to allow log file creation")
        
        # Give ClamAV a moment to fully start up after socket creation
        time.sleep(2)
        
        try:
            # Try Ubuntu ClamAV socket paths, prioritizing .ctl
            socket_paths = ["/var/run/clamav/clamd.ctl", "/var/run/clamav/clamd.sock"]
            last_exception = None
            
            for socket_path in socket_paths:
                self._log_result(f"Attempting to connect to ClamAV at {socket_path}...")
                try:
                    if os.path.exists(socket_path):
                        self.clam = pyclamd.ClamdUnixSocket(socket_path)
                        # Test connection to clamd
                        self.clam.ping()
                        self._log_result(f"Successfully connected to ClamAV daemon at {socket_path}.")
                        break # Connection successful
                    else:
                        self._log_result(f"Socket file {socket_path} does not exist.")
                        last_exception = FileNotFoundError(f"Socket file {socket_path} does not exist.")
                except (ConnectionError, OSError) as e:
                    self._log_result(f"Failed to connect to ClamAV at {socket_path}: {e}")
                    last_exception = e 
                    self.clam = None # Ensure clam is None if this path fails
                except Exception as e: # Catch other errors during connection attempt for this path
                    self._log_result(f"Unexpected error connecting to ClamAV at {socket_path}: {e}")
                    last_exception = e
                    self.clam = None # Ensure clam is None if this path fails
            
            if not self.clam:
                # All specified paths failed.
                if last_exception:
                    self._log_result(f"All ClamAV connection attempts to specified sockets failed. Last error: {last_exception}")
                    raise RuntimeError(f"Could not connect to ClamAV daemon on any specified socket. Last error: {last_exception}") from last_exception
                else:
                    # This case implies socket_paths was empty or os.path.exists was false for all and no other exceptions occurred.
                    self._log_result("All ClamAV connection attempts failed. No specified socket paths were found or accessible.")
                    raise RuntimeError("Could not connect to ClamAV daemon. No specified socket paths were found or accessible.")

        except RuntimeError: # Re-raise RuntimeError from the loop
            self._log_result(f"ClamAV initialization failed: {e}") # Log the re-raised error
            self.clam = None # Ensure clam is None
            raise # Re-raise the RuntimeError
        except Exception as e: # Catch any other unexpected error during the setup
            self._log_result(f"Outer error initializing ClamAV: {e}")
            self.clam = None # Ensure clam is None
            raise RuntimeError(f"Failed to initialize ClamAV due to an unexpected error: {e}") from e

        if not self.clam: # Should ideally be caught by exceptions above
             self._log_result("CRITICAL: ClamAV daemon is not available after initialization attempts. Malware scanning will be disabled.")
             # Depending on application requirements, you might want to raise an error here too or handle it gracefully.

    def _log_result(self, message):
        """Log results to the specified log file."""
        # Ensure log_path is absolute within the container, e.g., /app/network_log.txt
        log_path = os.path.join(self.base_dir, self.log_file)
        try:
            # Ensure the parent directory for the log file exists
            log_parent_dir = os.path.dirname(log_path)
            if log_parent_dir: # Will be self.base_dir if log_file has no slashes
                os.makedirs(log_parent_dir, exist_ok=True)

            # Check if the intended log_path is actually a directory
            if os.path.isdir(log_path):
                # If it's a directory, we cannot open it in append mode.
                # Log an error to stdout and skip file logging for this message.
                print(f"ERROR: Cannot write to log file. Path {log_path} is a directory.")
            else:
                # If it's not a directory (i.e., it's a file or does not exist yet), try to append.
                with open(log_path, "a") as f:
                    f.write(f"{message}\n")
        except Exception as e:
            # Catch any other exception during directory creation or file I/O
            print(f"Failed to write to log file {log_path}: {e}")
        
        # Per original behavior, always print the message to stdout as well.
        print(message)

    def scan_file_with_clamav(self, file_path):
        """Scan a file for malware using ClamAV."""
        if not self.clam:
            self._log_result("ClamAV not available, skipping file scan.")
            return False
            
        # file_path is relative to self.base_dir, e.g., "captured_files/somefile"
        absolute_path = os.path.join(self.base_dir, file_path)
        
        self._log_result(f"Attempting to scan file at: {absolute_path}")
            
        if not os.path.exists(absolute_path):
            self._log_result(f"ERROR scanning {absolute_path}: File path check failure: No such file or directory.")
            return False
            
        try:
            result = self.clam.scan_file(absolute_path)
            if result:
                # result is like {'/path/to/file': ('FOUND', 'MalwareName')}
                malware_name = result[absolute_path][1]
                self._log_result(f"Malware detected in file {absolute_path}: {malware_name}")
                return True
            else:
                self._log_result(f"No malware detected in file {absolute_path} by ClamAV.")
                return False
        except Exception as e:
            self._log_result(f"Error during ClamAV file scan for {absolute_path}: {e}")
            return False

    def scan_data_with_clamav(self, data_chunk):
        """Scan a chunk of data (bytes) for malware using ClamAV."""
        if not self.clam:
            self._log_result("ClamAV not available, skipping data scan.")
            return False
        if not data_chunk:
            self._log_result("No data provided for scanning.")
            return False
        try:
            # scan_stream returns {filename: (type, name)} if virus is found, None otherwise
            # For stream, filename is usually 'stream'
            result = self.clam.scan_stream(data_chunk)
            if result and 'stream' in result and result['stream'][0] == 'FOUND':
                malware_name = result['stream'][1]
                self._log_result(f"Malware detected in data chunk: {malware_name}")
                return True
            else:
                self._log_result("No malware detected in data chunk by ClamAV.")
                return False
        except Exception as e:
            self._log_result(f"Error during ClamAV data scan: {e}")
            return False

    def compute_file_hash(self, file_path):
        """Compute the SHA256 hash of a file."""
        absolute_path = os.path.join(self.base_dir, file_path)
        if not os.path.exists(absolute_path):
            self._log_result(f"ERROR computing hash for {absolute_path}: File not found.")
            return None
        try:
            with open(absolute_path, "rb") as f:
                file_data = f.read()
            file_hash = hashlib.sha256(file_data).hexdigest()
            self._log_result(f"SHA256 hash of file {absolute_path}: {file_hash}")
            return file_hash
        except Exception as e:
            self._log_result(f"Error computing file hash for {absolute_path}: {e}")
            return None

    def compute_data_hash(self, data_chunk):
        """Compute the SHA256 hash of a data chunk (bytes)."""
        if not data_chunk:
            self._log_result("No data provided for hashing.")
            return None
        try:
            data_hash = hashlib.sha256(data_chunk).hexdigest()
            self._log_result(f"SHA256 hash of data chunk: {data_hash}")
            return data_hash
        except Exception as e:
            self._log_result(f"Error computing data hash: {e}")
            return None

    def analyze_file(self, file_path):
        """Perform full malware analysis (ClamAV + hash) on a file."""
        self._log_result(f"Analyzing file: {file_path}")
        is_malware = self.scan_file_with_clamav(file_path)
        file_hash = self.compute_file_hash(file_path)
        analysis_result = {"file_path": file_path, "is_malware": is_malware, "hash": file_hash}
        self._log_result(f"File analysis result: {analysis_result}")
        return analysis_result

    def analyze_data_chunk(self, data_chunk):
        """Perform full malware analysis (ClamAV + hash) on a data chunk."""
        self._log_result(f"Analyzing data chunk (length: {len(data_chunk)} bytes)")
        is_malware = self.scan_data_with_clamav(data_chunk)
        data_hash = self.compute_data_hash(data_chunk)
        analysis_result = {"is_malware": is_malware, "hash": data_hash, "chunk_length": len(data_chunk)}
        self._log_result(f"Data chunk analysis result: {analysis_result}")
        return analysis_result

if __name__ == "__main__":
    detector = MalwareDetection()
    results = detector.analyze_file("captured_files/captured_file")
    print(results)