# -*- coding: utf-8 -*-
# src/bobbi_the_watchdog/core/malware_detection.py

"""
Module de detection de logiciels malveillants pour Bobbi The Watchdog.

Ce module gere la detection des malwares en utilisant ClamAV et le calcul
de hachage SHA256. Il prend en charge l'analyse des fichiers et des flux
de donnees en temps reel.

Classes:
    MalwareDetection: Classe principale pour la detection de malwares
"""

import pyclamd
import hashlib
import os
import time
from typing import Dict, Optional, Union, Any

class MalwareDetection:
    """
    Classe pour la detection de logiciels malveillants.
    
    Cette classe utilise ClamAV pour l'analyse antivirus et SHA256 pour
    le calcul des signatures de fichiers. Elle gere les fichiers et les
    flux de donnees en temps reel.
    
    Attributes:
        log_file (str): Chemin du fichier de journalisation
        base_dir (str): Repertoire de base pour les operations sur fichiers
        clam (pyclamd.ClamdUnixSocket): Instance de connexion a ClamAV
    """

    def __init__(self, log_file: str = "network_log.txt") -> None:
        """
        Initialise le detecteur de malwares.
        
        Args:
            log_file: Chemin du fichier de journalisation
        """
        self.log_file = log_file.rstrip('/')  # Assure un nom de fichier valide
        self.base_dir = "/app"  # Repertoire de base dans le conteneur
        self.clam = None
        
        # Preparation du fichier de log
        log_path = os.path.join(self.base_dir, self.log_file)
        if os.path.isdir(log_path):
            import shutil
            shutil.rmtree(log_path)
            print(f"Suppression du repertoire {log_path} pour la creation du fichier de log")
        
        # Delai pour demarrage complet de ClamAV
        time.sleep(2)
        
        try:
            # Tentative de connexion aux sockets ClamAV Ubuntu
            socket_paths = ["/var/run/clamav/clamd.ctl", "/var/run/clamav/clamd.sock"]
            last_exception = None
            
            for socket_path in socket_paths:
                self._log_result(f"Tentative de connexion a ClamAV sur {socket_path}...")
                try:
                    if os.path.exists(socket_path):
                        self.clam = pyclamd.ClamdUnixSocket(socket_path)
                        self.clam.ping()
                        self._log_result(f"Connexion reussie au daemon ClamAV sur {socket_path}.")
                        break
                    else:
                        self._log_result(f"Le fichier socket {socket_path} n'existe pas.")
                        last_exception = FileNotFoundError(f"Socket {socket_path} introuvable.")
                except (ConnectionError, OSError) as e:
                    self._log_result(f"Echec de connexion a ClamAV sur {socket_path}: {e}")
                    last_exception = e 
                    self.clam = None
                except Exception as e:
                    self._log_result(f"Erreur inattendue de connexion a ClamAV sur {socket_path}: {e}")
                    last_exception = e
                    self.clam = None
            
            if not self.clam:
                if last_exception:
                    self._log_result(f"Echec de toutes les tentatives de connexion ClamAV. Derniere erreur: {last_exception}")
                    raise RuntimeError(f"Impossible de se connecter au daemon ClamAV. Derniere erreur: {last_exception}") from last_exception
                else:
                    self._log_result("Echec de toutes les tentatives de connexion ClamAV. Aucun socket accessible.")
                    raise RuntimeError("Impossible de se connecter au daemon ClamAV. Aucun socket accessible.")

        except RuntimeError as e:
            self._log_result(f"Echec d'initialisation de ClamAV: {e}")
            self.clam = None
            raise
        except Exception as e:
            self._log_result(f"Erreur externe d'initialisation ClamAV: {e}")
            self.clam = None
            raise RuntimeError(f"Echec d'initialisation ClamAV: erreur inattendue: {e}") from e

    def _log_result(self, message: str) -> None:
        """
        Enregistre les resultats dans le fichier de log.
        
        Args:
            message: Message a journaliser
        """
        log_path = os.path.join(self.base_dir, self.log_file)
        try:
            log_parent_dir = os.path.dirname(log_path)
            if log_parent_dir:
                os.makedirs(log_parent_dir, exist_ok=True)

            if os.path.isdir(log_path):
                print(f"ERREUR: Impossible d'ecrire dans le fichier de log. {log_path} est un repertoire.")
            else:
                with open(log_path, "a") as f:
                    f.write(f"{message}\n")
        except Exception as e:
            print(f"Echec d'ecriture dans le fichier de log {log_path}: {e}")
        
        print(message)

    def scan_file_with_clamav(self, file_path: str) -> bool:
        """
        Analyse un fichier pour detecter des malwares avec ClamAV.
        
        Args:
            file_path: Chemin relatif du fichier a analyser
            
        Returns:
            bool: True si un malware est detecte, False sinon
        """
        if not self.clam:
            self._log_result("ClamAV non disponible, analyse ignoree.")
            return False
            
        absolute_path = os.path.join(self.base_dir, file_path)
        self._log_result(f"Analyse du fichier: {absolute_path}")
            
        if not os.path.exists(absolute_path):
            self._log_result(f"ERREUR: {absolute_path} - Fichier introuvable.")
            return False
            
        try:
            result = self.clam.scan_file(absolute_path)
            if result:
                malware_name = result[absolute_path][1]
                self._log_result(f"Malware detecte dans {absolute_path}: {malware_name}")
                return True
            else:
                self._log_result(f"Aucun malware detecte dans {absolute_path}.")
                return False
        except Exception as e:
            self._log_result(f"Erreur lors de l'analyse ClamAV de {absolute_path}: {e}")
            return False

    def scan_data_with_clamav(self, data_chunk: bytes) -> bool:
        """
        Analyse un bloc de donnees pour detecter des malwares.
        
        Args:
            data_chunk: Donnees a analyser
            
        Returns:
            bool: True si un malware est detecte, False sinon
        """
        if not self.clam:
            self._log_result("ClamAV non disponible, analyse ignoree.")
            return False
        if not data_chunk:
            self._log_result("Aucune donnee fournie pour l'analyse.")
            return False
            
        try:
            result = self.clam.scan_stream(data_chunk)
            if result and 'stream' in result and result['stream'][0] == 'FOUND':
                malware_name = result['stream'][1]
                self._log_result(f"Malware detecte dans le flux: {malware_name}")
                return True
            else:
                self._log_result("Aucun malware detecte dans le flux.")
                return False
        except Exception as e:
            self._log_result(f"Erreur lors de l'analyse du flux: {e}")
            return False

    def compute_file_hash(self, file_path: str) -> Optional[str]:
        """
        Calcule le hachage SHA256 d'un fichier.
        
        Args:
            file_path: Chemin relatif du fichier
            
        Returns:
            str | None: Hachage SHA256 ou None en cas d'erreur
        """
        absolute_path = os.path.join(self.base_dir, file_path)
        if not os.path.exists(absolute_path):
            self._log_result(f"ERREUR: {absolute_path} - Fichier introuvable.")
            return None
            
        try:
            with open(absolute_path, "rb") as f:
                file_data = f.read()
            file_hash = hashlib.sha256(file_data).hexdigest()
            self._log_result(f"Hachage SHA256 de {absolute_path}: {file_hash}")
            return file_hash
        except Exception as e:
            self._log_result(f"Erreur de calcul du hachage pour {absolute_path}: {e}")
            return None

    def compute_data_hash(self, data_chunk: bytes) -> Optional[str]:
        """
        Calcule le hachage SHA256 d'un bloc de donnees.
        
        Args:
            data_chunk: Donnees a hasher
            
        Returns:
            str | None: Hachage SHA256 ou None en cas d'erreur
        """
        if not data_chunk:
            self._log_result("Aucune donnee fournie pour le hachage.")
            return None
            
        try:
            data_hash = hashlib.sha256(data_chunk).hexdigest()
            self._log_result(f"Hachage SHA256 du flux: {data_hash}")
            return data_hash
        except Exception as e:
            self._log_result(f"Erreur de calcul du hachage du flux: {e}")
            return None

    def analyze_file(self, file_path: str) -> Dict[str, Any]:
        """
        Effectue une analyse complete (ClamAV + hachage) d'un fichier.
        
        Args:
            file_path: Chemin relatif du fichier
            
        Returns:
            Dict[str, Any]: Resultats de l'analyse
        """
        self._log_result(f"Analyse du fichier: {file_path}")
        is_malware = self.scan_file_with_clamav(file_path)
        file_hash = self.compute_file_hash(file_path)
        
        analysis_result = {
            "file_path": file_path,
            "is_malware": is_malware,
            "hash": file_hash
        }
        self._log_result(f"Resultat de l'analyse: {analysis_result}")
        return analysis_result

    def analyze_data_chunk(self, data_chunk: bytes) -> Dict[str, Any]:
        """
        Effectue une analyse complete (ClamAV + hachage) d'un bloc de donnees.
        
        Args:
            data_chunk: Donnees a analyser
            
        Returns:
            Dict[str, Any]: Resultats de l'analyse
        """
        self._log_result(f"Analyse du flux (taille: {len(data_chunk)} octets)")
        is_malware = self.scan_data_with_clamav(data_chunk)
        data_hash = self.compute_data_hash(data_chunk)
        
        analysis_result = {
            "is_malware": is_malware,
            "hash": data_hash,
            "chunk_length": len(data_chunk)
        }
        self._log_result(f"Resultat de l'analyse du flux: {analysis_result}")
        return analysis_result

if __name__ == "__main__":
    detector = MalwareDetection()
    results = detector.analyze_file("captured_files/captured_file")
    print(results)